import { Request, Response } from 'express';
import jwt from 'jsonwebtoken';
import { MarriageApplication } from '../models/marriage.models';
import { AtrocityApplication } from '../models/atrocity.models';
import { Application } from '../models/application.models';
import { BeneficiaryProfile } from '../models/beneficiaryProfile.models';
import { MockDataService } from '../services/mockData.service';
import { AuditService } from '../services/audit.service';
import { NotificationService } from '../services/notification.service';
import ApiResponse from '../utility/ApiResponse';
import { ApiError } from '../utility/ApiError';
import { asyncHandler } from '../utility/asyncHandler';

// Submit Intercaste Marriage Application
export const submitIntercasteMarriageApplication = asyncHandler(async (req: Request, res: Response) => {
  const authHeader = req.headers.authorization;
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    throw new ApiError(401, "Authorization token required");
  }

  const token = authHeader.substring(7);
  let decoded: any;
  
  try {
    decoded = jwt.verify(token, process.env.JWT_SECRET!);
  } catch (error) {
    throw new ApiError(401, "Invalid or expired token");
  }

  if (!decoded || decoded.role !== 'session') {
    throw new ApiError(401, "Valid session token required");
  }

  const { beneficiaryId } = decoded;
  
  const {
    marriageRegistrationId,
    spouseName,
    spouseCategory,
    spouseAadhaarNumber,
    supportingDocuments,
    applicationReason
  } = req.body;

  // Validate required fields
  if (!marriageRegistrationId || !spouseName || !spouseCategory || !spouseAadhaarNumber) {
    throw new ApiError(400, "Marriage registration ID, spouse details are required");
  }

  // Verify beneficiary exists
  const beneficiary = await BeneficiaryProfile.findOne({ userId: beneficiaryId })
    .populate('userId', 'aadhaarNumber mobileNumber');
  
  if (!beneficiary) {
    throw new ApiError(404, "Beneficiary profile not found");
  }

  const user = beneficiary.userId as any;

  // Verify marriage certificate
  const marriageVerification = MockDataService.verifyIntercasteMarriage(
    marriageRegistrationId,
    user.aadhaarNumber
  );

  if (!marriageVerification.success) {
    throw new ApiError(400, marriageVerification.message);
  }

  if (!marriageVerification.isIntercaste) {
    throw new ApiError(400, "This is not an intercaste marriage. Both spouses belong to the same category.");
  }

  // Verify spouse details match marriage certificate
  const spouseFromCertificate = marriageVerification.marriageDetails?.spouse;
  if (spouseFromCertificate?.name !== spouseName || 
      spouseFromCertificate?.aadhaarNumber !== spouseAadhaarNumber ||
      spouseFromCertificate?.category !== spouseCategory) {
    throw new ApiError(400, "Spouse details do not match with marriage certificate");
  }

  // Generate application number - will be auto-generated by the model
  // const applicationNumber = `APP-${Date.now()}-${Math.random().toString(36).substr(2, 6).toUpperCase()}`;

  // Create marriage application using the dedicated model
  const application = new MarriageApplication({
    beneficiaryId,
    marriageDetails: {
      marriageRegistrationId,
      marriageDate: new Date(marriageVerification.marriageDetails?.marriageDate),
      registrationAuthority: marriageVerification.marriageDetails?.registrationAuthority,
      spouseDetails: {
        name: spouseName,
        category: spouseCategory,
        aadhaarNumber: spouseAadhaarNumber
      },
      verificationStatus: 'VERIFIED'
    },
    documentsUploaded: supportingDocuments ? supportingDocuments.map((doc: any) => ({
      documentType: doc.type || 'Supporting Document',
      fileName: doc.fileName || 'document.pdf',
      fileUrl: doc.url || doc.fileUrl,
      uploadedAt: new Date(),
      verificationStatus: 'PENDING'
    })) : [],
    applicationStatus: 'SUBMITTED',
    submittedAt: new Date(),
    applicationReason: applicationReason || 'Financial assistance for intercaste marriage'
  });

  await application.save();

  // Log audit
  console.log('ðŸ” AUDIT: Application submitted', { beneficiaryId, applicationId: application.applicationId, applicationType: 'INTERCASTE_MARRIAGE' });

  // Send notification
  try {
    await (NotificationService as any).sendSMSImmediate(
      user.mobileNumber,
      `à¤†à¤ªà¤•à¤¾ à¤…à¤‚à¤¤à¤°à¥à¤œà¤¾à¤¤à¥€à¤¯ à¤µà¤¿à¤µà¤¾à¤¹ à¤†à¤µà¥‡à¤¦à¤¨ ${application.applicationId} à¤¸à¤«à¤²à¤¤à¤¾à¤ªà¥‚à¤°à¥à¤µà¤• à¤œà¤®à¤¾ à¤¹à¥à¤† à¤¹à¥ˆà¥¤ à¤¸à¥à¤¥à¤¿à¤¤à¤¿ à¤œà¤¾à¤‚à¤šà¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ à¤ªà¥‹à¤°à¥à¤Ÿà¤² à¤¦à¥‡à¤–à¥‡à¤‚à¥¤`
    );
  } catch (error) {
    console.log('SMS notification failed:', error);
  }

  res.status(201).json(
    new ApiResponse(201, {
      applicationId: application.applicationId,
      status: 'SUBMITTED',
      message: 'Intercaste marriage application submitted successfully'
    }, "Application submitted successfully")
  );
});

// Get Application Status
export const getApplicationStatus = asyncHandler(async (req: Request, res: Response) => {
  const { applicationId } = req.params;
  
  let application = null;
  
  // Try to find in MarriageApplication first
  application = await MarriageApplication.findOne({ applicationId })
    .populate('beneficiaryId', 'aadhaarData.fullName')
    .populate('assignedOfficer', 'name designation');
    
  // If not found, try AtrocityApplication
  if (!application) {
    application = await AtrocityApplication.findOne({ applicationId })
      .populate('beneficiaryId', 'aadhaarData.fullName')
      .populate('assignedOfficer', 'name designation');
  }

  if (!application) {
    throw new ApiError(404, "Application not found");
  }

  res.status(200).json(
    new ApiResponse(200, application, "Application details retrieved successfully")
  );
});

// Get Beneficiary Applications
export const getBeneficiaryApplications = asyncHandler(async (req: Request, res: Response) => {
  const authHeader = req.headers.authorization;
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    throw new ApiError(401, "Authorization token required");
  }

  const token = authHeader.substring(7);
  let decoded: any;
  
  try {
    decoded = jwt.verify(token, process.env.JWT_SECRET!);
  } catch (error) {
    throw new ApiError(401, "Invalid or expired token");
  }

  if (!decoded || decoded.role !== 'session') {
    throw new ApiError(401, "Valid session token required");
  }

  const { beneficiaryId } = decoded;

  // Get applications from both models
  const marriageApplications = await MarriageApplication.find({ beneficiaryId })
    .sort({ submittedAt: -1 })
    .populate('assignedOfficer', 'name designation');
    
  const atrocityApplications = await AtrocityApplication.find({ beneficiaryId })
    .sort({ submittedAt: -1 })
    .populate('assignedOfficer', 'name designation');

  // Combine and sort by creation date
  const allApplications = [
    ...marriageApplications.map(app => ({ ...app.toObject(), applicationType: 'INTERCASTE_MARRIAGE' })),
    ...atrocityApplications.map(app => ({ ...app.toObject(), applicationType: 'ATROCITY_RELIEF' }))
  ].sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());

  res.status(200).json(
    new ApiResponse(200, allApplications, "Applications retrieved successfully")
  );
});

// Verify Marriage Certificate (utility endpoint)
export const verifyMarriageCertificate = asyncHandler(async (req: Request, res: Response) => {
  const { marriageRegistrationId } = req.body;
  
  if (!marriageRegistrationId) {
    throw new ApiError(400, "Marriage registration ID is required");
  }

  const marriageData = MockDataService.getMarriageCertificate(marriageRegistrationId);
  
  if (!marriageData.success) {
    throw new ApiError(404, marriageData.message);
  }

  res.status(200).json(
    new ApiResponse(200, marriageData.data, "Marriage certificate verified successfully")
  );
});

// Check if Marriage is Intercaste
export const checkIntercasteMarriage = asyncHandler(async (req: Request, res: Response) => {
  const authHeader = req.headers.authorization;
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    throw new ApiError(401, "Authorization token required");
  }

  const token = authHeader.substring(7);
  let decoded: any;
  
  try {
    decoded = jwt.verify(token, process.env.JWT_SECRET!);
  } catch (error) {
    throw new ApiError(401, "Invalid or expired token");
  }

  if (!decoded || decoded.role !== 'session') {
    throw new ApiError(401, "Valid session token required");
  }

  const { beneficiaryId } = decoded;
  const { marriageRegistrationId } = req.body;
  
  if (!marriageRegistrationId) {
    throw new ApiError(400, "Marriage registration ID is required");
  }

  // Get beneficiary details
  const beneficiary = await BeneficiaryProfile.findOne({ userId: beneficiaryId })
    .populate('userId', 'aadhaarNumber mobileNumber');
    
  if (!beneficiary) {
    throw new ApiError(404, "Beneficiary profile not found");
  }

  const user = beneficiary.userId as any;

  const verification = MockDataService.verifyIntercasteMarriage(
    marriageRegistrationId,
    user.aadhaarNumber
  );

  res.status(200).json(
    new ApiResponse(200, verification, "Marriage verification completed")
  );
});